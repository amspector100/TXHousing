

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TXHousing.utilities.measurements &mdash; TXHousing 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> TXHousing
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utilities.html">Autogenerated Documentation for utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_processing.html">Autogenerated Documentation for data_processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html">Autogenerated Documentation for analysis package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TXHousing</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>TXHousing.utilities.measurements</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for TXHousing.utilities.measurements</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions which focus on efficienctly measuring distances and area.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="k">import</span> <span class="n">CategoricalDtype</span>

<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">simple</span><span class="p">,</span> <span class="n">spatial_joins</span>

<span class="n">texas_places_path</span> <span class="o">=</span> <span class="s2">&quot;data/cb_2017_48_place_500k/cb_2017_48_place_500k.shp&quot;</span>


<span class="c1"># Haversine, area, dist to center - None of these use spatial joins -------------------------------------------------</span>

<div class="viewcode-block" id="haversine"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.haversine">[docs]</a><span class="k">def</span> <span class="nf">haversine</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">lon1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lat1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Haversine function calculates distance (in miles) between two points in lat/long coordinates. See</span>
<span class="sd">    https://gis.stackexchange.com/questions/279109/calculate-distance-between-a-coordinate-and-a-county-in-geopandas</span>

<span class="sd">    :param point1: Shapely point. Long then lat.</span>
<span class="sd">    :param point2: Shapely point. Long then lat.</span>
<span class="sd">    :param lon1, lat1, lon2, lat2: Alternatively, supply the longitudes and lattitudes manually.</span>
<span class="sd">    :return: Distance in miles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Retrieve lat and long</span>
    <span class="k">if</span> <span class="n">lon1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lat1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">point1</span><span class="o">.</span><span class="n">coords</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">lon2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lat2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">point2</span><span class="o">.</span><span class="n">coords</span><span class="p">[:][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:])</span>

    <span class="c1"># convert decimal degrees to radians</span>
    <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="p">[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">])</span>

    <span class="c1"># haversine formula</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">3956</span>  <span class="c1"># Radius of earth in miles. Use 6371 for km</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">r</span></div>

<div class="viewcode-block" id="calculate_dist_to_center"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.calculate_dist_to_center">[docs]</a><span class="k">def</span> <span class="nf">calculate_dist_to_center</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="n">drop_centroids</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculates distance to the center of the city using haversine on the centroids of objects</span>

<span class="sd">    :param gdf: A GeoDataFrame, with lat/long crs. Can either have point or polygon geometry.</span>
<span class="sd">    :param lat: Latitude of the center of the city</span>
<span class="sd">    :param long: Longitude of the center of the city.</span>
<span class="sd">    :param drop_centroids: Boolean, default true. If true, drop the centroids inplace after calculation.</span>
<span class="sd">    :return: Pandas Series of floats (distances from center).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">long</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dist_to_center</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dist</span>

    <span class="k">if</span> <span class="s1">&#39;centroids&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;centroids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>

    <span class="n">distances</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;centroids&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">dist_to_center</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">drop_centroids</span><span class="p">:</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;centroids&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distances</span></div>

<div class="viewcode-block" id="get_area_in_units"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.get_area_in_units">[docs]</a><span class="k">def</span> <span class="nf">get_area_in_units</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">newproj</span> <span class="o">=</span> <span class="s1">&#39;epsg:2277&#39;</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">3.58701</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">),</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="n">final_projection</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reproject</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Get the area of each polygon of a geodataframe in units of your choice (defaults to square miles). This function</span>
<span class="sd">    relies on crs transformations, so for large/complex gdfs, this function is very computationally expensive.</span>

<span class="sd">    :param gdf: Geodataframe with polygons in the geometry column.</span>
<span class="sd">    :param geometry_column: Geometry column of the geodataframe, defaults to &#39;geometry&#39;</span>
<span class="sd">    :param newproj: The new projection to use to calculate units. Defaults to epsg:2277, which is probably fine for</span>
<span class="sd">        Austin/Dallas/Houston and is in feet.</span>
<span class="sd">    :param scale: A scale to multiply by. Defaults to 3.58701*10**(-8) which is the number of square miles in a square</span>
<span class="sd">        foot.</span>
<span class="sd">    :param name: The name of the new column that will be created to store the area information. Defaults to &#39;area&#39;.</span>
<span class="sd">    :param final_projection: The final projection that the returned gdf should be in. Defaults to the gdf&#39;s current crs.</span>
<span class="sd">    :param reproject: If False, do not reproject the data after calculating area (this is useful to save time in specific</span>
<span class="sd">        cases).</span>
<span class="sd">    :type reproject: Boolean</span>

<span class="sd">    :return: The geodataframe with a column named name (defaults to &#39;area&#39;) which has the area of each polygon in</span>
<span class="sd">    the desired units.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get final projection</span>
    <span class="k">if</span> <span class="n">final_projection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">final_projection</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span>

    <span class="c1"># Project and get area</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="n">newproj</span><span class="p">})</span>
    <span class="n">gdf</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="n">gdf</span><span class="p">[</span><span class="n">geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Optionally reproject (usually do this)</span>
    <span class="k">if</span> <span class="n">reproject</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">final_projection</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span></div>

<span class="c1"># These functions group gdfs into successive rings in distance from city center. They employ spatial joins and are</span>
<span class="c1"># somewhat expensive.</span>


<span class="c1"># Part 5: Create dist from city center graphs, for points and polygons ------------------------------------------------</span>

<div class="viewcode-block" id="order_radii"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.order_radii">[docs]</a><span class="k">def</span> <span class="nf">order_radii</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function which properly orders wacky indexes for pandas dataframes. If inplace = False, works</span>
<span class="sd">    with a copy of the data to prevent global effects. &quot;&quot;&quot;</span>

    <span class="c1"># Sort all the floatable values (i.e. 1, 2.5, 3, 4, 5).</span>
    <span class="k">if</span> <span class="n">inplace</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Consider some floats</span>
    <span class="n">sorted_values</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="n">simple</span><span class="o">.</span><span class="n">will_it_float</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>

    <span class="c1"># Need to process index at the same time to avoid NaNs from cropping up</span>
    <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">simple</span><span class="o">.</span><span class="n">will_it_float</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
                <span class="n">item</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>
    <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process_index</span><span class="p">)</span>
    <span class="n">sorted_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">process_index</span><span class="p">,</span> <span class="n">sorted_values</span><span class="p">))</span>

    <span class="c1"># Add the other values to the final list</span>
    <span class="n">other_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">simple</span><span class="o">.</span><span class="n">will_it_float</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;order_radii may not order properly if more than one value cannot be coerced to a float&#39;</span><span class="p">)</span>

    <span class="n">sorted_values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other_values</span><span class="p">)</span>

    <span class="c1"># Create categorical dtype</span>
    <span class="n">radii</span> <span class="o">=</span>  <span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">sorted_values</span><span class="p">,</span> <span class="n">ordered</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="points_intersect_rings"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.points_intersect_rings">[docs]</a><span class="k">def</span> <span class="nf">points_intersect_rings</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                           <span class="n">geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">per_square_mile</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a gdf of points, calculates the distance of each point from the center of the city. Can also group by</span>
<span class="sd">    a categorical variable or alternatively calculate the mean/median of a continuous variable.</span>

<span class="sd">    :param gdf: GDF in points geometry.</span>
<span class="sd">    :param lat: The latitude of the center of the rings.</span>
<span class="sd">    :param long: The longitude of the center of the rings.</span>
<span class="sd">    :param factor: A factor of the gdf to condition on or calculate means/medians of, e.g. &#39;Race&#39; or&#39;Population&#39;</span>
<span class="sd">    :param step: Number of miles where the ring radiates outwards.</span>
<span class="sd">    :param maximum: Max radius (miles)</span>
<span class="sd">    :param categorical: If true, will only calculate percent land (or % of points) in the radius, conditional on the</span>
<span class="sd">        factor if factor is not None.</span>
<span class="sd">    :param by: Defaults to &quot;mean&quot;. If categorical = False, use &quot;by&quot; to determine how to calculate averages over points.</span>
<span class="sd">    :param geometry_column: name of geometry column. Default geometry.</span>
<span class="sd">    :param per_square_mile: if true, divide by the area of the ring.</span>
<span class="sd">    :param maximum: float, defualts to None. If not None, will group everything greater than this maximum into a single</span>
<span class="sd">        category.</span>
<span class="sd">    :return: If factor is None, a pd Series which lists the number of points by distance from city center. If</span>
<span class="sd">        categorical = True and factor is None, a pandas Dataframe which lists the number of points by distance  from the</span>
<span class="sd">        city center (index) against their categorical value from the factor (columns). Lastly, if categorical = False and</span>
<span class="sd">        factor is not None, returns a pd Series of the mean/median of the factor conditional on distance to city center.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get distance from center of city, in miles currently</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">long</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rounded_dist_to_center</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
        <span class="n">rdist</span> <span class="o">=</span> <span class="n">step</span><span class="o">*</span><span class="p">((</span><span class="n">dist</span> <span class="o">//</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Do this to get smoother bins (i.e. always round up)</span>
        <span class="k">return</span> <span class="n">rdist</span>

    <span class="c1"># Handle crs and apply</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">}:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;In points_intersect_rings call, forced to transform gdf to lat long&#39;</span><span class="p">)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">})</span>

    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rounded_dist_to_center</span><span class="p">)</span>

    <span class="c1"># Group ouotliers together if told</span>
    <span class="k">if</span> <span class="n">maximum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">group_outliers</span><span class="p">(</span><span class="n">dist_to_center</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dist_to_center</span> <span class="o">&gt;</span> <span class="n">maximum</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;+&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dist_to_center</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">group_outliers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">per_square_mile</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;In points_intersect_rings, dropping all points about the maximum because per_square_mile is True.&#39;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">simple</span><span class="o">.</span><span class="n">will_it_float</span><span class="p">)]</span>


    <span class="c1"># Get counts if no factor is provided</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;dist_to_center&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">)[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="c1"># Get counts by factor level if factor is categorical</span>
    <span class="k">elif</span> <span class="n">categorical</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">,</span> <span class="n">factor</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Get mean and median else</span>
    <span class="k">elif</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="n">factor</span><span class="p">,</span> <span class="s1">&#39;dist_to_center&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">)[</span><span class="n">factor</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="n">factor</span><span class="p">,</span> <span class="s1">&#39;dist_to_center&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;dist_to_center&#39;</span><span class="p">)[</span><span class="n">factor</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>

    <span class="c1"># Warn user if they supplied a bad arg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In points_intersect_rings call, when categorical = False and factors is not None, &quot;by&quot; argument must</span>
<span class="s2">        either equal &quot;mean&quot; or &quot;median&quot; - you put &quot;</span><span class="si">{}</span><span class="s2">&quot; &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">by</span><span class="p">))</span>

    <span class="c1"># If told, get area per square mile</span>
    <span class="k">if</span> <span class="n">per_square_mile</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">get_area_ring</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">step</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">areas</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">get_area_ring</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">areas</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>

        <span class="c1"># Return result</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">order_radii</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<span class="c1"># Radius from city center for polygon data</span>
<div class="viewcode-block" id="polygons_intersect_rings"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.measurements.polygons_intersect_rings">[docs]</a><span class="k">def</span> <span class="nf">polygons_intersect_rings</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">newproj</span> <span class="o">=</span> <span class="s1">&#39;epsg:2277&#39;</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">maximum</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                             <span class="n">group_outliers</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">outlier_maximum</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span> <span class="n">city</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given a gdf of polygons, groups the polygons by distance from the center of the city and calculates the</span>
<span class="sd">    percent of area of the city that the polygons cover. Can also group by a categorical variable or alternatively</span>
<span class="sd">    calculate the mean/median of a continuous variable (adjusting for the area of the polygons).</span>

<span class="sd">    :param gdf: Geopandas GeoDataFrame, in polygon geometry.</span>
<span class="sd">    :param factor: A factor of the gdf to condition on or calculate means/medians of e.g. &#39;Race&#39; or &#39;Population&#39;</span>
<span class="sd">    :param lat: The latitude of the center of the rings.</span>
<span class="sd">    :param long: The longitude of the center of the rings.</span>
<span class="sd">    :param newproj: the new projection system necessarily used in this. Defaults to 2277 which is good for Austin and</span>
<span class="sd">        fine for Texas. Note units in this are in feet.</span>
<span class="sd">    :param step: Number of miles where the ring radiates outwards.</span>
<span class="sd">    :param maximum: Max radius (miles)</span>
<span class="sd">    :param geometry_column: name of geometry column. Default geometry.</span>
<span class="sd">    :param categorical: If true, will only calculate percent land (or % of points) in the radius. Else will calculate</span>
<span class="sd">        mean by area.</span>
<span class="sd">    :param city: If city is notnot &quot;none&quot;, if factor is &quot;none&quot;, will read the shapefile of the boundaries of the city</span>
<span class="sd">        to ensure more accurate calculations. (Otherwise, for a ring of size 12, the area of the circle might be</span>
<span class="sd">        greater than the area of the city inside the circle).</span>
<span class="sd">    :param group_outliers: Boolean, defaults to true. If true, group everything with a distance greater than the maximum</span>
<span class="sd">        into one group (of maximum size).</span>
<span class="sd">    :param outlier_maximum: Float, defaults to 35. For computational efficiency, this function will not consider outliers</span>
<span class="sd">        higher than this distance from the cneter of the city.</span>
<span class="sd">    :return: Dataframe or Series</span>

<span class="sd">    Note::</span>

<span class="sd">    To ensure accurate results, this function will break up polygons which straddle the boundary between being</span>
<span class="sd">    (for example) 5-6 miles from the city center as opposed to 6-7 miles from the city center; this makes it</span>
<span class="sd">    computationally expensive. To calculate similar results more cheaply with slightly less accuracy, just take the</span>
<span class="sd">    centroids of the geodataframe and apply points_intersect_rings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feet_to_mile</span> <span class="o">=</span> <span class="mi">5280</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">process_geometry</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">geometry_column</span> <span class="o">=</span> <span class="n">geometry_column</span><span class="p">)</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Necessarily will have to transform into new epsg code in order to efficiently calculate this.</span>
    <span class="c1"># Here, gdf should be in (lat, long) format</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No CRS set, assuming lat and long data before transformation.&#39;</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">}</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="n">newproj</span><span class="p">})</span>


    <span class="c1"># Get center and initialize output</span>
    <span class="n">center_latlong</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">long</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
    <span class="n">center_series</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">center_latlong</span><span class="p">)</span>
    <span class="n">center_series</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">}</span>
    <span class="n">center_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">center_series</span><span class="p">)</span>
    <span class="n">center_gdf</span> <span class="o">=</span> <span class="n">center_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s1">&#39;init&#39;</span><span class="p">:</span><span class="n">newproj</span><span class="p">})</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">center_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>

    <span class="c1"># Possibly get city shape</span>
    <span class="k">if</span> <span class="n">city</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">place_shapes</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">texas_places_path</span><span class="p">)</span>
        <span class="n">place_shapes</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span> <span class="s1">&#39;epsg:4326&#39;</span><span class="p">}</span>
        <span class="n">city_shape</span> <span class="o">=</span> <span class="n">place_shapes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">place_shapes</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">city</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Initialize result. If categorical, need a dataframe (one column for each unique value). Else, use a pd.Series.</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">categorical</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">factor</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">categorical</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># To make this play nicely with regulation data, just in case. Can&#39;t harm either way.</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="n">factor</span><span class="p">]</span><span class="o">.</span><span class="n">notnull</span><span class="p">()]</span>

    <span class="n">gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
    <span class="n">spatial_index</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">sindex</span>


    <span class="n">radius</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="n">maximum</span> <span class="o">-</span> <span class="n">step</span><span class="p">:</span>

        <span class="n">radius</span> <span class="o">+=</span> <span class="n">step</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">feet_to_mile</span><span class="o">*</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">feet_to_mile</span><span class="o">*</span><span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">step</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">city</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">circle</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">city_shape</span><span class="p">)</span>

        <span class="c1"># Get kwargss to pass to fragment call (we will fragment more as the circle we&#39;re dealing with gets bigger)</span>
        <span class="n">horiz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span>

        <span class="c1"># Call intersection function</span>
        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial_joins</span><span class="o">.</span><span class="n">polygons_intersect_single_polygon</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">circle</span><span class="p">,</span> <span class="n">spatial_index</span><span class="p">,</span>
                                                                             <span class="n">factors</span> <span class="o">=</span> <span class="n">factor</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="n">categorical</span><span class="p">,</span>
                                                                             <span class="n">account_for_area</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">divide_area_by</span> <span class="o">=</span> <span class="s1">&#39;nonempty&#39;</span><span class="p">,</span>
                                                                             <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">horiz</span> <span class="o">=</span> <span class="n">horiz</span><span class="p">,</span> <span class="n">vert</span> <span class="o">=</span> <span class="n">vert</span><span class="p">)</span>

        <span class="c1"># And adjust to sum to 1 for categorical calls</span>
        <span class="k">if</span> <span class="n">categorical</span> <span class="ow">and</span> <span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>


    <span class="c1"># If this optional arg is true, then lump everything else into one category</span>
    <span class="k">if</span> <span class="n">group_outliers</span><span class="p">:</span>

        <span class="c1"># Create circle</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">feet_to_mile</span><span class="o">*</span><span class="n">outlier_maximum</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">feet_to_mile</span><span class="o">*</span><span class="n">radius</span><span class="p">))</span>

        <span class="c1"># In this case, the denominator is the total area within the ring</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;+&#39;</span>

        <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial_joins</span><span class="o">.</span><span class="n">polygons_intersect_single_polygon</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">circle</span><span class="p">,</span> <span class="n">spatial_index</span><span class="p">,</span>
                                                                             <span class="n">factors</span> <span class="o">=</span> <span class="n">factor</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="n">categorical</span><span class="p">,</span>
                                                                             <span class="n">account_for_area</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">divide_area_by</span> <span class="o">=</span> <span class="s1">&#39;nonempty&#39;</span><span class="p">,</span>
                                                                             <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">horiz</span> <span class="o">=</span> <span class="n">horiz</span><span class="p">,</span> <span class="n">vert</span> <span class="o">=</span> <span class="n">vert</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">order_radii</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Asher Spector.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>