

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Autogenerated Documentation for utilities &mdash; TXHousing 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Autogenerated Documentation for data_processing" href="data_processing.html" />
    <link rel="prev" title="Welcome to TXHousing’s documentation!" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> TXHousing
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Autogenerated Documentation for utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-TXHousing.utilities.simple">Simple Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-TXHousing.utilities.spatial_joins">Spatial Join Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-TXHousing.utilities.measurements">Measurement Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_processing.html">Autogenerated Documentation for data_processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html">Autogenerated Documentation for analysis package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TXHousing</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Autogenerated Documentation for utilities</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/utilities.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="autogenerated-documentation-for-utilities">
<h1>Autogenerated Documentation for utilities<a class="headerlink" href="#autogenerated-documentation-for-utilities" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-TXHousing.utilities.simple">
<span id="simple-utilities"></span><h2>Simple Utilities<a class="headerlink" href="#module-TXHousing.utilities.simple" title="Permalink to this headline">¶</a></h2>
<p>Contains (i) nonspatial helper functions, (ii) simple spatial processing functions, and
(iii) a couple of shapely-based manipulations</p>
<dl class="function">
<dt id="TXHousing.utilities.simple.convert_to_hex">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">convert_to_hex</code><span class="sig-paren">(</span><em>rgba_color</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#convert_to_hex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.convert_to_hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts rgba colors to hexcodes. Adapted from
<a class="reference external" href="https://stackoverflow.com/questions/35516318/plot-colored-polygons-with-geodataframe-in-folium">https://stackoverflow.com/questions/35516318/plot-colored-polygons-with-geodataframe-in-folium</a></p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.fragment">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">fragment</code><span class="sig-paren">(</span><em>polygon</em>, <em>horiz=10</em>, <em>vert=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#fragment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>Fragment polygon into smaller pieces. This is used to (vastly) improve spatial tree efficiency on large polygons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>polygon</strong> (<em>shapely polygon</em>) – Polygon to fragment</li>
<li><strong>horiz</strong> (<em>int</em>) – Number of horizontal fragments, defaults to 10</li>
<li><strong>vert</strong> (<em>int</em>) – Number of vertical fragments, defaults to 10</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of smaller polygons which are a partition of the input polygon.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.get_urban_core">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">get_urban_core</code><span class="sig-paren">(</span><em>lat</em>, <em>long</em>, <em>radius</em>, <em>scale=5280</em>, <em>newproj='epsg:2277'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#get_urban_core"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.get_urban_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a polygon representing the urban core of a city. Based on the shapely’s buffer method, but combined with
crs transformations so you get to pick the units.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lat</strong> – The latitude of the center of the city.</li>
<li><strong>long</strong> – The longitude of the center of the city.</li>
<li><strong>radius</strong> – The radius in units of your choice; see the scale and newproj parameters.</li>
<li><strong>scale</strong> – Defaults to 5280, feet per mile.</li>
<li><strong>newproj</strong> – The new projection to use to calculate this distance (by default epsg:2277, which is in feat).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a geopandas geodataframe with a single column (geometry) of length one (polygon) which represents the
urban core.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.make_point_grid">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">make_point_grid</code><span class="sig-paren">(</span><em>gdf</em>, <em>horiz=20</em>, <em>vert=20</em>, <em>factor=None</em>, <em>by='mean'</em>, <em>geometry_column='geometry'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#make_point_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.make_point_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geodataframe of points, partition them into a rectangular grid and calculate either the number of points in
each rectangle or the mean or median of a factor associated with the points for each rectangle. This is used to
make choropleths out of point data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gdf</strong> – Geodataframe, with point geometry presumably.</li>
<li><strong>horiz</strong> – Number of horizontal boxes</li>
<li><strong>vert</strong> – Number of vertical boxes</li>
<li><strong>factor</strong> – The (continuous) value with which to take the mean/median of the points. Defaults to None.</li>
<li><strong>by</strong> – ‘mean’ or ‘median’. Meaningless unless you have the factor column.</li>
<li><strong>geometry_column</strong> – The column the points are contained in. These should be shapely points in lat/long form.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">geodataframe with grid geometry and a ‘value’ column</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.process_geometry">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">process_geometry</code><span class="sig-paren">(</span><em>gdf</em>, <em>geometry_column='geometry'</em>, <em>drop_multipolygons=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#process_geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.process_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Processing for polygon-based gdfs: makes geometries valid and possibly drops multipolygons.</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.process_points">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">process_points</code><span class="sig-paren">(</span><em>points</em>, <em>geometry_column='geometry'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#process_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.process_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Processing for point-based gdfs: ignores invalid points</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.retrieve_coords">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">retrieve_coords</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#retrieve_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.retrieve_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves coords and reverses their order for shapely point. (Reverses because folium and GeoPandas use opposite lat/long conventions).</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.simple.will_it_float">
<code class="descclassname">TXHousing.utilities.simple.</code><code class="descname">will_it_float</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/simple.html#will_it_float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.simple.will_it_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether an object can be converted to a float.</p>
</dd></dl>

</div>
<div class="section" id="module-TXHousing.utilities.spatial_joins">
<span id="spatial-join-utilities"></span><h2>Spatial Join Utilities<a class="headerlink" href="#module-TXHousing.utilities.spatial_joins" title="Permalink to this headline">¶</a></h2>
<p>Fast intersection functions</p>
<dl class="function">
<dt id="TXHousing.utilities.spatial_joins.fast_polygon_intersection">
<code class="descclassname">TXHousing.utilities.spatial_joins.</code><code class="descname">fast_polygon_intersection</code><span class="sig-paren">(</span><em>small_polygon_gdf</em>, <em>large_polygon_gdf</em>, <em>small_geometry_column='geometry'</em>, <em>large_geometry_column='geometry'</em>, <em>large_name_column=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/spatial_joins.html#fast_polygon_intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.spatial_joins.fast_polygon_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a gdf of small polygons (i.e. parcels) and a gdf of large polygons (i.e. municipal boundaries), calculates the
large polygon in which each small polygon lies. This function is based on the points_intersect_multiple_polygons
function and therefore assumes that each small polygon will lie in at most one of the large polygons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>small_polygon_gdf</strong> – A gdf of small polygons (i.e. parcels)</li>
<li><strong>large_polygon_gdf</strong> – A gdf of large polygons (i.e. municipal boundaries)</li>
<li><strong>small_geometry_column</strong> – The geometry column of the small_polygon_gdf.</li>
<li><strong>large_geometry_column</strong> – The geometry column of the large_polygon_gdf.</li>
<li><strong>large_name_column</strong> – Column for the names of each large polygon; if none will use the index of the large_polygon_gdf.</li>
<li><strong>kwargs</strong> – Kwargs to pass to the “fragment” function in the TXHousing.utilities.simple module. Fragmenting polygons
speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the
only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pandas series mapping the index of the small polygons to the names of the large polygons. If an index
does not appear in the returned series, that is because the small polygon corresponding to that index did not
lie inside any of the large polygons.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.spatial_joins.get_averages_by_area">
<code class="descclassname">TXHousing.utilities.spatial_joins.</code><code class="descname">get_averages_by_area</code><span class="sig-paren">(</span><em>data_source</em>, <em>other_geometries</em>, <em>features</em>, <em>density_flag=False</em>, <em>data_source_geometry_column='geometry'</em>, <em>other_geometries_column='geometry'</em>, <em>drop_multipolygons=True</em>, <em>account_method=None</em>, <em>horiz=1</em>, <em>vert=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/spatial_joins.html#get_averages_by_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.spatial_joins.get_averages_by_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Get averages of features from data_source by area. Data_source and other_geometries should have the
same crs initially. This is a wrapper for polygons_intersect_single_polygon and is therefore quite accurate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_source</strong> (<em>GeoDataFrame</em>) – The data source, usually block data. Must have polygon geometry.</li>
<li><strong>other_geometries</strong> – Will calculate features each row of this gdf from the data source. Must have polygon
geometry.</li>
<li><strong>features</strong> (<em>str</em><em> or </em><em>list</em>) – The feature in question. Can also be a list of features, i.e. [‘B01001e1’, ‘B01001e2’]</li>
<li><strong>density_flag</strong> (<em>Boolean</em>) – Default False. If True, will assume that the ‘feature’ is already units per area and will not
divide the feature by the area of the data source polygons.</li>
<li><strong>data_source_geometry_column</strong> – geometry column for data_source</li>
<li><strong>other_geometries_column</strong> – geometry column for other_geometries</li>
<li><strong>account_method</strong> – The method by which to account for the % of an area which is not residential (this prevents
population-related estimates from being too low). Can either be None, ‘percent_residential’, or ‘percent_land’
Defaults to None (although wrappers of this function may have different defaults).</li>
<li><strong>horiz</strong> – When fragmenting polygons, number of horizontal fragments to make. Defaults to 1.</li>
<li><strong>vert</strong> – When fragmenting polygons, number of vertical fragments to make. Defaults to 1.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">other_geometries but with a new column, feature, which has the averages by area.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.spatial_joins.points_intersect_multiple_polygons">
<code class="descclassname">TXHousing.utilities.spatial_joins.</code><code class="descname">points_intersect_multiple_polygons</code><span class="sig-paren">(</span><em>points_gdf</em>, <em>polygons_gdf</em>, <em>points_spatial_index=None</em>, <em>points_geometry_column='geometry'</em>, <em>polygons_geometry_column='geometry'</em>, <em>polygons_names_column=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/spatial_joins.html#points_intersect_multiple_polygons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.spatial_joins.points_intersect_multiple_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a gdf of points and a gdf of polygons, calculates the polygon in which each point lies. This function assumes
that each point will lie in at most one of the polygons. If that assumption is not true, use instead the
points_intersect_single_polygon function and apply it to the geometry column of a polygon gdf.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points_gdf</strong> – A geodataframe of points data.</li>
<li><strong>polygons_gdf</strong> – A geodataframe of polygons data.</li>
<li><strong>points_spatial_index</strong> – Optional; the spatial_index of the points geodataframe. If not supplied, the function
will automatically generate the spatial index.</li>
<li><strong>points_geometry_column</strong> – Geometry column for the points data.</li>
<li><strong>polygons_geometry_column</strong> – Geometry column for the polygon data.</li>
<li><strong>polygons_names_column</strong> – Column for the names of each polygon; if none will use the index of the polygons_gdf.</li>
<li><strong>kwargs</strong> – Kwargs to pass to the “fragment” function in the TXHousing.utilities.simple module. Fragmenting polygons
speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the
only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pandas series mapping the index of the points_gdf to the names of the polygons. If an index does not
appear in the returned series, that is because the point corresponding to that index did not lie inside any of
the polygons.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.spatial_joins.points_intersect_single_polygon">
<code class="descclassname">TXHousing.utilities.spatial_joins.</code><code class="descname">points_intersect_single_polygon</code><span class="sig-paren">(</span><em>points</em>, <em>polygon</em>, <em>spatial_index</em>, <em>points_geometry_column='geometry'</em>, <em>factors=None</em>, <em>categorical=True</em>, <em>by='mean'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/spatial_joins.html#points_intersect_single_polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.spatial_joins.points_intersect_single_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Given many points and a polygon, finds one of three things. (1) If factors = None, the number of points inside the
polygon, (2) if factors is not None and categorical = True, the number of points inside the polygon subsetted by a
categorical factors, (3) if factors is not None and categorical = False, the summarized value (mean/median)
of a factors associated with each point of each point inside the polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> – A GDF with a points geometry column</li>
<li><strong>polygon</strong> – The polygon to see whether the points are inside.</li>
<li><strong>spatial_index</strong> – The spatial index of the points</li>
<li><strong>factors</strong> – The factors to average over (if continuous) or subset by the cartesian product of (if categorical).
This may be a list or a string.</li>
<li><strong>categorical</strong> – If True, then the factor should be treated as a categorical variable.</li>
<li><strong>by</strong> – If categorical is False, can either summarize using by = ‘mean’ or by = ‘median’</li>
<li><strong>**kwargs</strong> – <p>Kwargs to pass to the “fragment” function in the TXHousing.utilities.simple module. Fragmenting polygons
speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the
only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Pandas series</p>
</td>
</tr>
</tbody>
</table>
<p>Note: it is often useful to apply this function to an entire gdf of polygons.</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.spatial_joins.polygons_intersect_single_polygon">
<code class="descclassname">TXHousing.utilities.spatial_joins.</code><code class="descname">polygons_intersect_single_polygon</code><span class="sig-paren">(</span><em>small_polygons</em>, <em>polygon</em>, <em>spatial_index</em>, <em>geometry_column='geometry'</em>, <em>factors=None</em>, <em>categorical=True</em>, <em>account_for_area=True</em>, <em>divide_area_by='polygon'</em>, <em>by='mean'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/spatial_joins.html#polygons_intersect_single_polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.spatial_joins.polygons_intersect_single_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Given many polygons (i.e. parcels) and a larger polygon (i.e. county boundary), finds one of three things.
(1) If factor = None, the percent area of the large polygon that is covered by the small polygons
(2) If factor is not None and categorical = True, the percent area of the large polygon that is covered by the small
polygons conditional on the factor
(3) if factor is not None and categorical = False, the summarized value (mean/median) of a factor associated with
each polygon inside the polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>small_polygons</strong> – A GDF with a polygon geometry column</li>
<li><strong>polygon</strong> – The polygon to see whether the small_polygons are inside.</li>
<li><strong>spatial_index</strong> – The spatial index of the small_polygons</li>
<li><strong>factors</strong> – The factors to average over (if continuous) or subset by the cartesian product of (if categorical).</li>
<li><strong>categorical</strong> – If True, factors will be treated as categorical variables.</li>
<li><strong>by</strong> – If categorical is False, can summarize with by = ‘mean’ or by = ‘median’</li>
<li><strong>account_for_area</strong> – Default True. If True, instead of returning the mean of the factor, this will return the
dot product of the mean and the area of each small_polygon that intersects the large_polygon divided by the area
of the large polygon (happens if categorical is False, by = ‘mean’, and account_for_area = True). Also,
if factor = None, divides answer by area of polygon.</li>
<li><strong>divide_area_by</strong> – Defaults to ‘polygon’. This parameter determines what to divide the result by.
If divide_area_by = ‘polygon’, then this divides by the area of the polygon. If divide_area_by = ‘nonempty’, it
will divide by the total area of the intersection between the polygon and small_polygons. Else, it will simply
return without dividing.</li>
<li><strong>**kwargs</strong> – <p>Kwargs to pass to the “fragment” function in the TXHousing.utilities.simple module. Fragmenting polygons
speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the
only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float (if categorical = False or factor is None) or pandas series</p>
</td>
</tr>
</tbody>
</table>
<p>Note: it is often useful to apply this function to an entire gdf of polygons.</p>
</dd></dl>

</div>
<div class="section" id="module-TXHousing.utilities.measurements">
<span id="measurement-utilities"></span><h2>Measurement Utilities<a class="headerlink" href="#module-TXHousing.utilities.measurements" title="Permalink to this headline">¶</a></h2>
<p>Functions which focus on efficienctly measuring distances and area.</p>
<dl class="function">
<dt id="TXHousing.utilities.measurements.calculate_dist_to_center">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">calculate_dist_to_center</code><span class="sig-paren">(</span><em>gdf</em>, <em>lat</em>, <em>long</em>, <em>drop_centroids=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#calculate_dist_to_center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.calculate_dist_to_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates distance to the center of the city using haversine on the centroids of objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gdf</strong> – A GeoDataFrame, with lat/long crs. Can either have point or polygon geometry.</li>
<li><strong>lat</strong> – Latitude of the center of the city</li>
<li><strong>long</strong> – Longitude of the center of the city.</li>
<li><strong>drop_centroids</strong> – Boolean, default true. If true, drop the centroids inplace after calculation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Pandas Series of floats (distances from center).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.measurements.get_area_in_units">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">get_area_in_units</code><span class="sig-paren">(</span><em>gdf</em>, <em>geometry_column='geometry'</em>, <em>newproj='epsg:2277'</em>, <em>scale=3.58701e-08</em>, <em>name='area'</em>, <em>final_projection=None</em>, <em>reproject=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#get_area_in_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.get_area_in_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the area of each polygon of a geodataframe in units of your choice (defaults to square miles). This function
relies on crs transformations, so for large/complex gdfs, this function is very computationally expensive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gdf</strong> – Geodataframe with polygons in the geometry column.</li>
<li><strong>geometry_column</strong> – Geometry column of the geodataframe, defaults to ‘geometry’</li>
<li><strong>newproj</strong> – The new projection to use to calculate units. Defaults to epsg:2277, which is probably fine for
Austin/Dallas/Houston and is in feet.</li>
<li><strong>scale</strong> – A scale to multiply by. Defaults to 3.58701*10**(-8) which is the number of square miles in a square
foot.</li>
<li><strong>name</strong> – The name of the new column that will be created to store the area information. Defaults to ‘area’.</li>
<li><strong>final_projection</strong> – The final projection that the returned gdf should be in. Defaults to the gdf’s current crs.</li>
<li><strong>reproject</strong> (<em>Boolean</em>) – If False, do not reproject the data after calculating area (this is useful to save time in specific
cases).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The geodataframe with a column named name (defaults to ‘area’) which has the area of each polygon in</p>
</td>
</tr>
</tbody>
</table>
<p>the desired units.</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.measurements.haversine">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">haversine</code><span class="sig-paren">(</span><em>point1</em>, <em>point2</em>, <em>lon1=None</em>, <em>lat1=None</em>, <em>lon2=None</em>, <em>lat2=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#haversine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.haversine" title="Permalink to this definition">¶</a></dt>
<dd><p>Haversine function calculates distance (in miles) between two points in lat/long coordinates. See
<a class="reference external" href="https://gis.stackexchange.com/questions/279109/calculate-distance-between-a-coordinate-and-a-county-in-geopandas">https://gis.stackexchange.com/questions/279109/calculate-distance-between-a-coordinate-and-a-county-in-geopandas</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point1</strong> – Shapely point. Long then lat.</li>
<li><strong>point2</strong> – Shapely point. Long then lat.</li>
<li><strong>lat1</strong><strong>, </strong><strong>lon2</strong><strong>, </strong><strong>lat2</strong> (<em>lon1</em><em>,</em>) – Alternatively, supply the longitudes and lattitudes manually.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Distance in miles.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.measurements.order_radii">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">order_radii</code><span class="sig-paren">(</span><em>data</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#order_radii"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.order_radii" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function which properly orders wacky indexes for pandas dataframes. If inplace = False, works
with a copy of the data to prevent global effects.</p>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.measurements.points_intersect_rings">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">points_intersect_rings</code><span class="sig-paren">(</span><em>gdf</em>, <em>lat</em>, <em>long</em>, <em>factor=None</em>, <em>step=1</em>, <em>categorical=True</em>, <em>by='mean'</em>, <em>geometry_column='geometry'</em>, <em>per_square_mile=True</em>, <em>maximum=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#points_intersect_rings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.points_intersect_rings" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a gdf of points, calculates the distance of each point from the center of the city. Can also group by
a categorical variable or alternatively calculate the mean/median of a continuous variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gdf</strong> – GDF in points geometry.</li>
<li><strong>lat</strong> – The latitude of the center of the rings.</li>
<li><strong>long</strong> – The longitude of the center of the rings.</li>
<li><strong>factor</strong> – A factor of the gdf to condition on or calculate means/medians of, e.g. ‘Race’ or’Population’</li>
<li><strong>step</strong> – Number of miles where the ring radiates outwards.</li>
<li><strong>maximum</strong> – Max radius (miles)</li>
<li><strong>categorical</strong> – If true, will only calculate percent land (or % of points) in the radius, conditional on the
factor if factor is not None.</li>
<li><strong>by</strong> – Defaults to “mean”. If categorical = False, use “by” to determine how to calculate averages over points.</li>
<li><strong>geometry_column</strong> – name of geometry column. Default geometry.</li>
<li><strong>per_square_mile</strong> – if true, divide by the area of the ring.</li>
<li><strong>maximum</strong> – float, defualts to None. If not None, will group everything greater than this maximum into a single
category.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">If factor is None, a pd Series which lists the number of points by distance from city center. If
categorical = True and factor is None, a pandas Dataframe which lists the number of points by distance  from the
city center (index) against their categorical value from the factor (columns). Lastly, if categorical = False and
factor is not None, returns a pd Series of the mean/median of the factor conditional on distance to city center.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TXHousing.utilities.measurements.polygons_intersect_rings">
<code class="descclassname">TXHousing.utilities.measurements.</code><code class="descname">polygons_intersect_rings</code><span class="sig-paren">(</span><em>gdf</em>, <em>lat</em>, <em>long</em>, <em>factor=None</em>, <em>newproj='epsg:2277'</em>, <em>step=1</em>, <em>maximum=20</em>, <em>categorical=True</em>, <em>geometry_column='geometry'</em>, <em>group_outliers=True</em>, <em>outlier_maximum=35</em>, <em>city=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/TXHousing/utilities/measurements.html#polygons_intersect_rings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#TXHousing.utilities.measurements.polygons_intersect_rings" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a gdf of polygons, groups the polygons by distance from the center of the city and calculates the
percent of area of the city that the polygons cover. Can also group by a categorical variable or alternatively
calculate the mean/median of a continuous variable (adjusting for the area of the polygons).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gdf</strong> – Geopandas GeoDataFrame, in polygon geometry.</li>
<li><strong>factor</strong> – A factor of the gdf to condition on or calculate means/medians of e.g. ‘Race’ or ‘Population’</li>
<li><strong>lat</strong> – The latitude of the center of the rings.</li>
<li><strong>long</strong> – The longitude of the center of the rings.</li>
<li><strong>newproj</strong> – the new projection system necessarily used in this. Defaults to 2277 which is good for Austin and
fine for Texas. Note units in this are in feet.</li>
<li><strong>step</strong> – Number of miles where the ring radiates outwards.</li>
<li><strong>maximum</strong> – Max radius (miles)</li>
<li><strong>geometry_column</strong> – name of geometry column. Default geometry.</li>
<li><strong>categorical</strong> – If true, will only calculate percent land (or % of points) in the radius. Else will calculate
mean by area.</li>
<li><strong>city</strong> – If city is notnot “none”, if factor is “none”, will read the shapefile of the boundaries of the city
to ensure more accurate calculations. (Otherwise, for a ring of size 12, the area of the circle might be
greater than the area of the city inside the circle).</li>
<li><strong>group_outliers</strong> – Boolean, defaults to true. If true, group everything with a distance greater than the maximum
into one group (of maximum size).</li>
<li><strong>outlier_maximum</strong> – Float, defaults to 35. For computational efficiency, this function will not consider outliers
higher than this distance from the cneter of the city.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Dataframe or Series</p>
</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<p>To ensure accurate results, this function will break up polygons which straddle the boundary between being
(for example) 5-6 miles from the city center as opposed to 6-7 miles from the city center; this makes it
computationally expensive. To calculate similar results more cheaply with slightly less accuracy, just take the
centroids of the geodataframe and apply points_intersect_rings.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="data_processing.html" class="btn btn-neutral float-right" title="Autogenerated Documentation for data_processing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to TXHousing’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Asher Spector.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>