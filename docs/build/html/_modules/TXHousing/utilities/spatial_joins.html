

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TXHousing.utilities.spatial_joins &mdash; TXHousing 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> TXHousing
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../utilities.html">Autogenerated Documentation for utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_processing.html">Autogenerated Documentation for data_processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html">Autogenerated Documentation for analysis package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TXHousing</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>TXHousing.utilities.spatial_joins</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for TXHousing.utilities.spatial_joins</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Fast intersection functions&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">simple</span>

<div class="viewcode-block" id="points_intersect_single_polygon"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.spatial_joins.points_intersect_single_polygon">[docs]</a><span class="k">def</span> <span class="nf">points_intersect_single_polygon</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">spatial_index</span><span class="p">,</span> <span class="n">points_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                             <span class="n">factors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given many points and a polygon, finds one of three things. (1) If factors = None, the number of points inside the</span>
<span class="sd">    polygon, (2) if factors is not None and categorical = True, the number of points inside the polygon subsetted by a</span>
<span class="sd">    categorical factors, (3) if factors is not None and categorical = False, the summarized value (mean/median)</span>
<span class="sd">    of a factors associated with each point of each point inside the polygon.</span>

<span class="sd">    :param points: A GDF with a points geometry column</span>
<span class="sd">    :param polygon: The polygon to see whether the points are inside.</span>
<span class="sd">    :param spatial_index: The spatial index of the points</span>
<span class="sd">    :param factors: The factors to average over (if continuous) or subset by the cartesian product of (if categorical).</span>
<span class="sd">        This may be a list or a string.</span>
<span class="sd">    :param categorical: If True, then the factor should be treated as a categorical variable.</span>
<span class="sd">    :param by: If categorical is False, can either summarize using by = &#39;mean&#39; or by = &#39;median&#39;</span>
<span class="sd">    :param **kwargs: Kwargs to pass to the &quot;fragment&quot; function in the TXHousing.utilities.simple module. Fragmenting polygons</span>
<span class="sd">        speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the</span>
<span class="sd">        only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</span>
<span class="sd">    :return: Pandas series</span>

<span class="sd">    Note: it is often useful to apply this function to an entire gdf of polygons.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get intersections</span>
    <span class="n">all_precise_matches_indexes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">grid_piece</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
        <span class="n">possible_matches_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spatial_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">grid_piece</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
        <span class="n">possible_matches</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">possible_matches_index</span><span class="p">]</span>

        <span class="c1"># Prevent weird indexing errors by ignoring empty results</span>
        <span class="k">if</span> <span class="n">possible_matches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">precise_matches_index</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">possible_matches</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">possible_matches</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">grid_piece</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">all_precise_matches_indexes</span> <span class="o">=</span> <span class="n">all_precise_matches_indexes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">precise_matches_index</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">precise_matches_index</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">precise_matches</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">all_precise_matches_indexes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">categorical</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">factors</span><span class="p">)[</span><span class="n">points_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="p">[</span><span class="n">factors</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="p">[</span><span class="n">factors</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;In points_intersect_polygon call, &quot;by&quot; must either equal &quot;mean&quot; or &quot;median,&quot; not &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">by</span><span class="p">))</span></div>


<div class="viewcode-block" id="polygons_intersect_single_polygon"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.spatial_joins.polygons_intersect_single_polygon">[docs]</a><span class="k">def</span> <span class="nf">polygons_intersect_single_polygon</span><span class="p">(</span><span class="n">small_polygons</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">spatial_index</span><span class="p">,</span> <span class="n">geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                                      <span class="n">factors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">account_for_area</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="n">divide_area_by</span> <span class="o">=</span> <span class="s1">&#39;polygon&#39;</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given many polygons (i.e. parcels) and a larger polygon (i.e. county boundary), finds one of three things.</span>
<span class="sd">    (1) If factor = None, the percent area of the large polygon that is covered by the small polygons</span>
<span class="sd">    (2) If factor is not None and categorical = True, the percent area of the large polygon that is covered by the small</span>
<span class="sd">    polygons conditional on the factor</span>
<span class="sd">    (3) if factor is not None and categorical = False, the summarized value (mean/median) of a factor associated with</span>
<span class="sd">    each polygon inside the polygon.</span>

<span class="sd">    :param small_polygons: A GDF with a polygon geometry column</span>
<span class="sd">    :param polygon: The polygon to see whether the small_polygons are inside.</span>
<span class="sd">    :param spatial_index: The spatial index of the small_polygons</span>
<span class="sd">    :param factors: The factors to average over (if continuous) or subset by the cartesian product of (if categorical).</span>
<span class="sd">    :param categorical: If True, factors will be treated as categorical variables.</span>
<span class="sd">    :param by: If categorical is False, can summarize with by = &#39;mean&#39; or by = &#39;median&#39;</span>
<span class="sd">    :param account_for_area: Default True. If True, instead of returning the mean of the factor, this will return the</span>
<span class="sd">        dot product of the mean and the area of each small_polygon that intersects the large_polygon divided by the area</span>
<span class="sd">        of the large polygon (happens if categorical is False, by = &#39;mean&#39;, and account_for_area = True). Also,</span>
<span class="sd">        if factor = None, divides answer by area of polygon.</span>
<span class="sd">    :param divide_area_by: Defaults to &#39;polygon&#39;. This parameter determines what to divide the result by.</span>
<span class="sd">        If divide_area_by = &#39;polygon&#39;, then this divides by the area of the polygon. If divide_area_by = &#39;nonempty&#39;, it</span>
<span class="sd">        will divide by the total area of the intersection between the polygon and small_polygons. Else, it will simply</span>
<span class="sd">        return without dividing.</span>
<span class="sd">    :param **kwargs: Kwargs to pass to the &quot;fragment&quot; function in the TXHousing.utilities.simple module. Fragmenting polygons</span>
<span class="sd">        speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the</span>
<span class="sd">        only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</span>
<span class="sd">    :return: float (if categorical = False or factor is None) or pandas series</span>

<span class="sd">    Note: it is often useful to apply this function to an entire gdf of polygons.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the indexes of the small polygons which intersect the big polygon</span>
    <span class="n">precise_matches_indexes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">grid_piece</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
        <span class="n">possible_matches_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spatial_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
        <span class="n">possible_matches</span> <span class="o">=</span> <span class="n">small_polygons</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">possible_matches_index</span><span class="p">]</span>

        <span class="c1"># Might speed things up a tiny bit; also might prevent weird indexing errors</span>
        <span class="k">if</span> <span class="n">possible_matches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">precise_matches_to_add</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">possible_matches</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">possible_matches</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">grid_piece</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">precise_matches_indexes</span> <span class="o">=</span> <span class="n">precise_matches_indexes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">precise_matches_to_add</span><span class="p">)</span>

    <span class="c1"># Calculate actual intersections</span>
    <span class="n">precise_matches</span> <span class="o">=</span> <span class="n">small_polygons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">precise_matches_indexes</span><span class="p">]</span>
    <span class="n">precise_matches</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">geometry_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">precise_matches</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
    <span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">precise_matches</span><span class="p">[</span><span class="n">geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span>

    <span class="c1"># Calculate answers</span>
    <span class="k">if</span> <span class="n">factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">account_for_area</span> <span class="ow">and</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;polygon&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">polygon</span><span class="o">.</span><span class="n">area</span>
        <span class="k">elif</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;nonempty&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot divide_area_by by the total area of the nonempty intersections when factor is None&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Group by categorical</span>
    <span class="k">elif</span> <span class="n">categorical</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">account_for_area</span> <span class="ow">and</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;nonempty&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">factors</span><span class="p">)[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">account_for_area</span> <span class="ow">and</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;polygon&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">factors</span><span class="p">)[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">precise_matches</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">factors</span><span class="p">)[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">factor_data</span> <span class="o">=</span> <span class="n">precise_matches</span><span class="p">[</span><span class="n">factors</span><span class="p">]</span>

        <span class="c1"># Transpose if there are multiple factors (for dot product)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">factor_data</span> <span class="o">=</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>

            <span class="c1"># Different division methods</span>
            <span class="k">if</span> <span class="n">account_for_area</span> <span class="ow">and</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;nonempty&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">account_for_area</span> <span class="ow">and</span> <span class="n">divide_area_by</span> <span class="o">==</span> <span class="s1">&#39;polygon&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">account_for_area</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">precise_matches</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">by</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">factor_data</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;In points_intersect_polygon call, &quot;by&quot; must either equal &quot;mean&quot; or &quot;median,&quot; not &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">by</span><span class="p">))</span></div>


<div class="viewcode-block" id="points_intersect_multiple_polygons"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.spatial_joins.points_intersect_multiple_polygons">[docs]</a><span class="k">def</span> <span class="nf">points_intersect_multiple_polygons</span><span class="p">(</span><span class="n">points_gdf</span><span class="p">,</span> <span class="n">polygons_gdf</span><span class="p">,</span> <span class="n">points_spatial_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">points_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">polygons_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                              <span class="n">polygons_names_column</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given a gdf of points and a gdf of polygons, calculates the polygon in which each point lies. This function assumes</span>
<span class="sd">    that each point will lie in at most one of the polygons. If that assumption is not true, use instead the</span>
<span class="sd">    points_intersect_single_polygon function and apply it to the geometry column of a polygon gdf.</span>

<span class="sd">    :param points_gdf: A geodataframe of points data.</span>
<span class="sd">    :param polygons_gdf: A geodataframe of polygons data.</span>
<span class="sd">    :param points_spatial_index: Optional; the spatial_index of the points geodataframe. If not supplied, the function</span>
<span class="sd">        will automatically generate the spatial index.</span>
<span class="sd">    :param points_geometry_column: Geometry column for the points data.</span>
<span class="sd">    :param polygons_geometry_column: Geometry column for the polygon data.</span>
<span class="sd">    :param polygons_names_column: Column for the names of each polygon; if none will use the index of the polygons_gdf.</span>
<span class="sd">    :param kwargs: Kwargs to pass to the &quot;fragment&quot; function in the TXHousing.utilities.simple module. Fragmenting polygons</span>
<span class="sd">        speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the</span>
<span class="sd">        only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</span>
<span class="sd">    :return: A pandas series mapping the index of the points_gdf to the names of the polygons. If an index does not</span>
<span class="sd">        appear in the returned series, that is because the point corresponding to that index did not lie inside any of</span>
<span class="sd">        the polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">points_spatial_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">points_spatial_index</span> <span class="o">=</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">sindex</span>

    <span class="c1"># Create lists of polygons/names from large_polygon_gdf</span>
    <span class="n">polygon_list</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="p">[</span><span class="n">polygons_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">polygons_names_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names_list</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="p">[</span><span class="n">polygons_names_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names_list</span> <span class="o">=</span> <span class="n">polygons_gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Loop through and find intersections</span>
    <span class="n">warning_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names_list</span><span class="p">,</span> <span class="n">polygon_list</span><span class="p">):</span>

        <span class="c1"># Fragment the polygons.</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">fragment</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">grid_piece</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">possible_intersections_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points_spatial_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">grid_piece</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>
            <span class="n">possible_intersections</span> <span class="o">=</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">possible_intersections_index</span><span class="p">]</span>
            <span class="n">precise_intersections_bools</span> <span class="o">=</span> <span class="n">possible_intersections</span><span class="p">[</span><span class="n">points_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">grid_piece</span><span class="p">)</span>
            <span class="n">precise_intersections</span> <span class="o">=</span> <span class="n">possible_intersections</span><span class="p">[</span><span class="n">precise_intersections_bools</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">precise_intersections</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">warning_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># Warn the user if a point lies in multiple polygons</span>
    <span class="k">if</span> <span class="n">warning_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In points_intersect_polygons, up to </span><span class="si">{}</span><span class="s2"> points are in multiple polygons, but points_intersect_polygons</span>
<span class="s2">         only returns one polygon per point (if a point is in two polygons, it will only show up as being in one).&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">warning_count</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="fast_polygon_intersection"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.spatial_joins.fast_polygon_intersection">[docs]</a><span class="k">def</span> <span class="nf">fast_polygon_intersection</span><span class="p">(</span><span class="n">small_polygon_gdf</span><span class="p">,</span> <span class="n">large_polygon_gdf</span><span class="p">,</span> <span class="n">small_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">large_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                              <span class="n">large_name_column</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given a gdf of small polygons (i.e. parcels) and a gdf of large polygons (i.e. municipal boundaries), calculates the</span>
<span class="sd">    large polygon in which each small polygon lies. This function is based on the points_intersect_multiple_polygons</span>
<span class="sd">    function and therefore assumes that each small polygon will lie in at most one of the large polygons.</span>

<span class="sd">    :param small_polygon_gdf: A gdf of small polygons (i.e. parcels)</span>
<span class="sd">    :param large_polygon_gdf: A gdf of large polygons (i.e. municipal boundaries)</span>
<span class="sd">    :param small_geometry_column: The geometry column of the small_polygon_gdf.</span>
<span class="sd">    :param large_geometry_column: The geometry column of the large_polygon_gdf.</span>
<span class="sd">    :param large_name_column: Column for the names of each large polygon; if none will use the index of the large_polygon_gdf.</span>
<span class="sd">    :param kwargs: Kwargs to pass to the &quot;fragment&quot; function in the TXHousing.utilities.simple module. Fragmenting polygons</span>
<span class="sd">        speeds up the computation for all but very small polygons. If you do not want to fragment the polygons (the</span>
<span class="sd">        only reason to do this is speed, it will not affect the results), pass in horiz = 1 and vert = 1 as kwargs.</span>
<span class="sd">    :return: A pandas series mapping the index of the small polygons to the names of the large polygons. If an index</span>
<span class="sd">        does not appear in the returned series, that is because the small polygon corresponding to that index did not</span>
<span class="sd">        lie inside any of the large polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get centroids</span>
    <span class="n">small_polygon_gdf</span><span class="p">[</span><span class="s1">&#39;centroids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">small_polygon_gdf</span><span class="p">[</span><span class="n">small_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
    <span class="n">small_polygon_gdf</span> <span class="o">=</span> <span class="n">small_polygon_gdf</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;centroids&#39;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">points_intersect_multiple_polygons</span><span class="p">(</span><span class="n">points_gdf</span> <span class="o">=</span> <span class="n">small_polygon_gdf</span><span class="p">,</span> <span class="n">polygons_gdf</span> <span class="o">=</span> <span class="n">large_polygon_gdf</span><span class="p">,</span>
                                                <span class="n">points_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;centroids&#39;</span><span class="p">,</span>
                                                <span class="n">polygons_geometry_column</span> <span class="o">=</span> <span class="n">large_geometry_column</span><span class="p">,</span>
                                                <span class="n">polygons_names_column</span> <span class="o">=</span> <span class="n">large_name_column</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">small_polygon_gdf</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">small_geometry_column</span><span class="p">)</span> <span class="c1"># Undo global effects on small_polygon_gdf</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="get_averages_by_area"><a class="viewcode-back" href="../../../utilities.html#TXHousing.utilities.spatial_joins.get_averages_by_area">[docs]</a><span class="k">def</span> <span class="nf">get_averages_by_area</span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span> <span class="n">other_geometries</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">density_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">data_source_geometry_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                             <span class="n">other_geometries_column</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">drop_multipolygons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">account_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">horiz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Get averages of features from data_source by area. Data_source and other_geometries should have the</span>
<span class="sd">    same crs initially. This is a wrapper for polygons_intersect_single_polygon and is therefore quite accurate.</span>

<span class="sd">    :param data_source: The data source, usually block data. Must have polygon geometry.</span>
<span class="sd">    :type data_source: GeoDataFrame</span>
<span class="sd">    :param other_geometries:  Will calculate features each row of this gdf from the data source. Must have polygon</span>
<span class="sd">        geometry.</span>
<span class="sd">    :param features: The feature in question. Can also be a list of features, i.e. [&#39;B01001e1&#39;, &#39;B01001e2&#39;]</span>
<span class="sd">    :type features: str or list</span>
<span class="sd">    :param density_flag: Default False. If True, will assume that the &#39;feature&#39; is already units per area and will not</span>
<span class="sd">        divide the feature by the area of the data source polygons.</span>
<span class="sd">    :type density_flag: Boolean</span>
<span class="sd">    :param data_source_geometry_column: geometry column for data_source</span>
<span class="sd">    :param other_geometries_column: geometry column for other_geometries</span>
<span class="sd">    :param account_method: The method by which to account for the % of an area which is not residential (this prevents</span>
<span class="sd">        population-related estimates from being too low). Can either be None, &#39;percent_residential&#39;, or &#39;percent_land&#39;</span>
<span class="sd">        Defaults to None (although wrappers of this function may have different defaults).</span>
<span class="sd">    :param horiz: When fragmenting polygons, number of horizontal fragments to make. Defaults to 1.</span>
<span class="sd">    :param vert: When fragmenting polygons, number of vertical fragments to make. Defaults to 1.</span>
<span class="sd">    :return: other_geometries but with a new column, feature, which has the averages by area.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Process features and make sure we won&#39;t be overwriting anything</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">features</span><span class="p">]</span>
    <span class="n">overwritten_features</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">if</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">other_geometries</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overwritten_features</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Some features are already present in other_geometries and would be overwritten by </span>
<span class="s2">        get_averages_by_area: they are </span><span class="si">{}</span><span class="s2">.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">overwritten_features</span><span class="p">))</span>

    <span class="c1"># Process crs</span>
    <span class="k">if</span> <span class="n">data_source</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">other_geometries</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The crs for data_source (</span><span class="si">{}</span><span class="s2">) and other_geometries (</span><span class="si">{}</span><span class="s2">) disagree.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_source</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">other_geometries</span><span class="o">.</span><span class="n">crs</span><span class="p">))</span>

    <span class="c1"># Process data for convenience (just to prevent multipolygons/invalid polygons from messing things up)</span>
    <span class="n">data_source</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">process_geometry</span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span> <span class="n">drop_multipolygons</span><span class="o">=</span><span class="n">drop_multipolygons</span><span class="p">)</span>
    <span class="n">data_source</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">data_source</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">data_source</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Start to rename the features to prevent global side effects</span>
    <span class="n">old_columns_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_density&#39;</span><span class="p">:</span><span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">}</span>
    <span class="n">new_columns_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="n">feature</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_density&#39;</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">}</span>
    <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_columns_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_columns_dictionary</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">density_flag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># If the features are not per area (i.e. population), then divide them to get feature densities (ie. population density)</span>

        <span class="c1"># Account for the percent of land in block groups that may not be populated. Default to None. This is mostly useful</span>
        <span class="c1"># for calculating populations of very small regions, i.e. population of municipal zones.</span>

        <span class="k">if</span> <span class="n">account_method</span> <span class="o">==</span> <span class="s1">&#39;percent_residential&#39;</span><span class="p">:</span>
            <span class="c1"># Using percent_residential accounting method</span>
            <span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;percent_residential&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">]</span> <span class="c1"># Ignore blocks which are &lt; .5% resid</span>
            <span class="n">densities</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;percent_residential&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">densities</span> <span class="o">=</span> <span class="n">densities</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="n">data_source_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">account_method</span> <span class="o">==</span> <span class="s1">&#39;water&#39;</span><span class="p">:</span>
            <span class="c1"># Using water accounting method</span>
            <span class="n">data_source</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;percent_land&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;ALAND&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="s2">&quot;ALAND&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;AWATER&#39;</span><span class="p">])</span>
            <span class="n">densities</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="s1">&#39;percent_land&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">densities</span> <span class="o">=</span> <span class="n">densities</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="n">data_source_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not using any accounting method</span>
            <span class="n">densities</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">data_source</span><span class="p">[</span><span class="n">data_source_geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If the features are already in units per area, then don&#39;t divide them.</span>
        <span class="n">densities</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">densities</span> <span class="o">=</span> <span class="n">densities</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="n">new_columns_dictionary</span><span class="p">)</span>
    <span class="n">data_source</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">densities</span><span class="p">)</span>

    <span class="n">other_geometries</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">process_geometry</span><span class="p">(</span><span class="n">other_geometries</span><span class="p">,</span> <span class="n">drop_multipolygons</span> <span class="o">=</span> <span class="n">drop_multipolygons</span><span class="p">)</span>

    <span class="c1"># Get spatial index</span>
    <span class="n">data_spatial_index</span> <span class="o">=</span> <span class="n">data_source</span><span class="o">.</span><span class="n">sindex</span>

    <span class="c1"># Quick function to apply to geometry column for other_geometries</span>
    <span class="k">def</span> <span class="nf">get_avg</span><span class="p">(</span><span class="n">polygon</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">polygons_intersect_single_polygon</span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">data_spatial_index</span><span class="p">,</span> <span class="n">factors</span> <span class="o">=</span> <span class="n">new_columns</span><span class="p">,</span>
                                                   <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">account_for_area</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">divide_area_by</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                   <span class="n">by</span> <span class="o">=</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">horiz</span> <span class="o">=</span> <span class="n">horiz</span><span class="p">,</span> <span class="n">vert</span> <span class="o">=</span> <span class="n">vert</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Get averages by area - this takes a while.</span>
    <span class="n">final_values</span> <span class="o">=</span> <span class="n">other_geometries</span><span class="p">[</span><span class="n">other_geometries_column</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_avg</span><span class="p">)</span>

    <span class="c1"># If the features were provided as densities, return them as densities</span>
    <span class="k">if</span> <span class="n">density_flag</span><span class="p">:</span>
        <span class="n">final_values</span> <span class="o">=</span> <span class="n">final_values</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other_geometries</span><span class="p">[</span><span class="n">other_geometries_column</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Rename columns</span>
    <span class="n">final_values</span> <span class="o">=</span> <span class="n">final_values</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="n">old_columns_dictionary</span><span class="p">)</span>

    <span class="c1"># Join and return</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">final_values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">final_values</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">other_geometries</span> <span class="o">=</span> <span class="n">other_geometries</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">final_values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">other_geometries</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Asher Spector.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>